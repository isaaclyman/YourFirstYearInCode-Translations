# You are an interpreter

_Edaqa Mortoray_

Programming is primarily about translation. You take the desires of a user and translate them into source code. It's a process requiring a strong understanding of technology, the users, and all the people involved in development.

I know a lot of you may wish to keep your head in the code, but becoming a great programmer depends on you becoming a great mediator. Imagination far outpaces our current technology, leading to extreme mismatches in what users expect and what our computers can actually do. As a programmer, you'll be required to temper those expectations and produce a nonetheless desirable product.

You'll need to empathize with the user and consult with colleagues on their views. Development is not a process that can be done by one person. Programmers represent the technology, which is a cornerstone to the process, but still only one part. Our products entirely hinge on the software doing something useful, but without teamwork working towards a shared vision, that'll never happen.

_Soft skills_ is often the term used to refer to this part of the job---interacting productively with users and teammates in pursuit of a common goal. I don't know if that term accurately represents this skill set. The ability to communicate is an _essential_ skill. Your ability to get inside the user's head is critical to the success of the project. The importance of you as a translator and mediator of technology cannot be overstated.


### Nobody cares about your code

Let's back up for a second, and start at the code. While it is only part of our job, it is the domain where a programmer's presence dominates. We own this artifact of development. It is our responsibility to create it, and we have to address all issues with the code.

The ability to write code is a significant competence that all programmers must develop. There is no way you can translate requests into code if you don't know how to write it. Your ability to translate is limited by your vocabulary.

Imagine having to work with somebody who doesn't share a language with you---say someone who only speaks Italian, while you only speak English. You'd need an interpreter that can translate for you. The quality of the translation is limited by the interpreter's understanding of both English _and_ Italian. If they can speak only a bit of Italian, their interpretation won't be natural, and your Italian colleague will have a hard time understanding what you meant to say. Similarly, it doesn't help if the translator speaks Italian fluently but is weak with English. The translator can formulate great sentences in Italian, but potentially from a misunderstanding of what you said.

In programming, you are an interpreter who must speak two languages. Code is one of the languages you need to speak. But you also need to speak the language of users and other developers in your company. It's irrelevant that you weave wondrous structures of code if you've misunderstood what you're supposed to be building. It's also pointless if you're a master empath, and you can understand the user perfectly, but you can't figure out how to express that in code.

Source code is a work artifact. It's there to support the high-level goals of the product. Ultimately, other than you and a few other programmers on your team, nobody cares about the code. It's all about the product. The user cares about what you've built and how it solves their problem, not so much about how you got there. Knowing this improves the appreciation of your work, and lets you make the right decisions.


###  Sharing the journey of the user

But what goals does the code need to support? Here we look to the users of the products: the people that will be installing the app on their phone, going to your web page, or downloading a desktop program. Understanding the people using our software is the highest priority of development. The user experience is our utmost goal.

You may have already heard about user stories, journeys, and personas. These are all tools that capture what the user wants. They should be used on most projects. It's actually hard to avoid them. Even if you don't use a strict method or have rigid formality, you will be considering the user's wishes in your project. Learning user tools, such as user stories and portraits, makes the process easier and more robust. But just like code, they are not the purpose of the project.

The purpose of user portraits and stories is to keep the focus on the user. A portrait tells us what job a user has, where they live, and what their goals are in life. We create these descriptions to better empathize with people using our product. If these people remain nameless and abstract, it's easy to forget about who they are.

Having a bit of formality, such as writing down our ideas, allows us to communicate with other teams. It's more comfortable to talk to other departments in the domain of the user than of technology. By talking about the product from the user's viewpoint, we stick to a universal language that everybody can understand. 

This is more challenging than talking about code. Code has a strict structure and lack of ambiguity. By contrast, human language is full of amorphous thoughts and wandering ideas. It's this lack of clarity that causes most issues within development. But as difficult as it may be, getting all departments to talk in the language of the user is worth it. It's how great software is made.

Much like the code isn't the product, the product isn't actually what the user wants. People have real-world tasks they wish to perform. They are willing to use a tool to get them done, but that's all it is: a means to an end. They may not even know what kind of tool they need (see Appendix A, "XY Problem"). This is why it's essential to talk in the language of the user, not the product. This subtle distinction in wording shifts the emphasis of development from technical requirements to user expectations.

For example, most people don't want a car for the purpose of having a car. Many people don't even want to drive, but they have a car to get to other locations.  These drivers care primarily about how they get somewhere with their vehicle. All the polish and extra features are pointless if it's hard to get somewhere. This is why things like public transit and taxis compete in the same market. When stating requirements, there's a significant difference between "wanting to own a car," and "wanting to travel between locations."

As another example, we have apps that allow us to organize events, from large to small. As the developer, you must keep in mind that the users are trying to hold an event. Your app is strictly a tool the organizer and attendees will use. Adding features that don't support the event organizers may at best be ignored by the user, and at worst get in the way. I'm sure we can all think of numerous apps that have nonsensical features in them.


### Everything and yet nothing we want

Ensuring our high-level requirements stay in the domain of our users addresses a fundamental problem. Technology can't do everything. Indeed, it doesn't come anywhere close to all the things we want to do. It can neither do them the way we want to do them nor understand what we actually want to do. Despite the extreme reliance we have on computers, they are still constrained when compared to all that is possible.

People's desires are not limited by technology. Their imagination shows no bounds. The expectations placed on technology tend to grow faster than technology itself advances. The demands placed on our computers, our gadgets, our networks, increase at alarming rates.

It's your job as a programmer to translate these unbound ideas into the limited space of what computers can actually do.

Losing track of the user's desires means you run the risk of working on the wrong things. While computers are limited in fulfilling user desires, they are unbound in their own domain. There's a wide variety of interesting, cool, and clever things we get a computer to do. It's easy to go down the road of technical beauty and stray far from the goals of the project.

Your focus on the user is what keeps you on track. For every line of code you write, for each module you install, for every host you deploy, you should be thinking about why the user needs this. If you're unable to draw a clear connection from your work to those high-level user goals, then something is wrong.


### Part of a larger development community

This focus on the user isn't only for programmers. No project can be done by programmers alone. Beyond the users, there are numerous other departments in a development company---designers, product owners, project managers, executives, quality assurance, and so on. You have to be able to converse with all of them about the product. You need to all be working towards a shared vision.

When somebody is left out of the process two things happen. First, their ideas, concerns, and requirements will be lost. This could result in a product of lower quality. Second, they feel marginalized and may become demotivated. Continuing in that state, they may become bitter and angry.

Tensions between teams are unfortunately all too familiar. A lot of this tension comes from people not properly communicating. While two teams may both fully believe in the product, an inability to share that vision can lead to hostility.

This discord can rapidly foment an unpleasant workplace. Nobody, including you, wants that. You work there, so keeping everything pleasant is in your best interest.

When things turn sour, productivity suffers. Not only are people, including you, demotivated, but they also end up working on the wrong things. The vision of the product becomes blurred, and ultimately it will fail. Instead of working together, everybody starts complaining about the other teams, how they don't listen and don't understand. 

Always remember, communication is a two-way street. The best way to be misunderstood by someone is by not talking to them. The best way to misunderstand someone is to close your ears to them.

As technology and time are limited, development is all about compromise. Not everything can be done. You, as a programmer, represent the technical side of the equation and must bring that knowledge to the negotiating table. Learn when to speak up and how to bring your concerns to the table.

If you can't build a particular feature, you must make that clear. If you have an idea for a feature that you think would help the user, but that nobody has mentioned yet, you should bring it up. If teams have requests for features that would help them and cost little, it's worthwhile to implement them to improve relations. If a high-visibility defect isn't getting fixed, you need to explain why that is.

Your prioritization process must be transparent, or tension will build. People are better able to accept the rejection of their ideas if they understand why they are being rejected. When people share a user-focused vision of the product, it's easier to identify high impact items and work on them first.


### Deserving of trust and autonomy

By having open processes and taking the time to listen to other teams, you'll build trust between each other. We rely on other teams to do their job. Just as we translate others' wishes into code, our own requirements will be converted into work processes in various teams. A request for artwork will be taken by a graphic artist and turned into images. We may ask marketing about our target user, and they'll come back with a persona. We have some idea of what they're doing, but the details of their work aren't our concern.

Development is not an exact science, and we all need room to maneuver if we're to get the system right. This is why it's crucial that requirements stay in the realm of users. The internals of the software must be flexible.

If requirements specify how a system should work internally, they interfere with the job of the programmer. The same goes for other departments. We aren't going to tell the graphics team what Photoshop layering technique they should be using, nor will we specify which ERP accounts the finance team should create to handle microtransactions. All teams have an expected amount of autonomy to perform their work.

This autonomy is based on everybody having a shared vision. We are all allowed, and expected, to contribute to the product's goals. That shared user domain is everybody's responsibility. This goes hand-in-hand with trust.  There's no way you can implement the system correctly if you don't know what those high-level goals are. 

Your flexibility and trust in your work depend on your understanding of the user. And that's tied to how well you can communicate with other teams.


### Becoming a great programmer

The emphasis for programming is often placed on coding. It's a comfortable place to start learning. Initially, it's likely the place where you lack the most skills. You've grown up in the real world, so to some degree, you've been working on your soft skills for years already.

Natural experience won't be enough, however. The particular skills needed for communication as a programmer require additional training. You need to take the time to learn the various techniques used for translating user desires into code. 

Don't feel overwhelmed though. Nobody can naturally do everything, and it'll take time to learn both code and communication. You'll be part of teams that will help you along. You and your teammates will have strengths and weaknesses to compliment each other.

You won't always act on your own. If you're a junior programmer, it's vital to have a mentor that can help you along. It's expected that programming teams discuss how the code should work. It's important to have a good leader who can make good decisions, and when needed, state precisely how some system should work. The dynamics within a programming team differ; however, the dynamic is always based on communication. And you should never let anybody hide the user's wishes from you.

Becoming a great programmer is primarily about your ability to act as an interpreter. You can't be ultra-productive only by being awesome at coding. Productivity is about choosing the right things to work on and figuring out the best way to cover the product requirements. Your value will be measured by how well you appear to be supporting the company. The better you perform with other people, the better you can tailor your effort towards high impact items.
